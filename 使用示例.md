# Cloudflare R2 代理服务 - 使用示例

## 一、基本访问示例

假设您的 Worker 部署后的 URL 是 `https://my-r2-proxy.your-subdomain.workers.dev`

### 1.1 公开文件访问
```
# 访问 R2 中的 public/image.jpg 文件
https://my-r2-proxy.your-subdomain.workers.dev/public/image.jpg
```

### 1.2 受保护文件访问
```
# 访问 R2 中的 private/document.pdf 文件（需要密钥）
https://my-r2-proxy.your-subdomain.workers.dev/protected/private/document.pdf?secret=mySecret123
```

## 二、前端页面集成示例

### 2.1 HTML 中直接引用图片
```html
<!-- 显示公开图片 -->
<img src="https://my-r2-proxy.your-subdomain.workers.dev/public/banner.jpg" alt="横幅图片">

<!-- 显示受保护的图片 -->
<img src="https://my-r2-proxy.your-subdomain.workers.dev/protected/private/logo.png?secret=mySecret123" alt="公司Logo">
```

### 2.2 JavaScript 动态加载文件
```javascript
// 加载公开文件
function loadPublicFile(filePath) {
    const url = `https://my-r2-proxy.your-subdomain.workers.dev/${filePath}`;
    window.open(url, '_blank');
}

// 加载受保护文件
function loadProtectedFile(filePath, secretKey) {
    const url = `https://my-r2-proxy.your-subdomain.workers.dev/protected/${filePath}?secret=${encodeURIComponent(secretKey)}`;
    window.open(url, '_blank');
}

// 使用示例
loadPublicFile('public/manual.pdf');
loadProtectedFile('private/confidential.pdf', 'mySecret123');
```

### 2.3 下载文件的 JavaScript 代码
```javascript
// 创建下载链接
function downloadFile(filePath, isProtected = false, secretKey = null) {
    let url;
    if (isProtected && secretKey) {
        url = `https://my-r2-proxy.your-subdomain.workers.dev/protected/${filePath}?secret=${encodeURIComponent(secretKey)}`;
    } else {
        url = `https://my-r2-proxy.your-subdomain.workers.dev/${filePath}`;
    }
    
    // 创建临时链接并触发下载
    const link = document.createElement('a');
    link.href = url;
    link.download = filePath.split('/').pop(); // 使用文件名作为下载名
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// 使用示例
downloadFile('public/guide.pdf'); // 下载公开文件
downloadFile('private/report.pdf', true, 'mySecret123'); // 下载受保护文件
```

## 三、后端集成示例

### 3.1 Node.js 示例
```javascript
const https = require('https');

// 下载公开文件
function downloadPublicFile(filePath, outputPath) {
    const url = `https://my-r2-proxy.your-subdomain.workers.dev/${filePath}`;
    const file = require('fs').createWriteStream(outputPath);
    
    https.get(url, (response) => {
        response.pipe(file);
        file.on('finish', () => {
            file.close();
            console.log('文件下载完成');
        });
    });
}

// 下载受保护文件
function downloadProtectedFile(filePath, secretKey, outputPath) {
    const url = `https://my-r2-proxy.your-subdomain.workers.dev/protected/${filePath}?secret=${encodeURIComponent(secretKey)}`;
    const file = require('fs').createWriteStream(outputPath);
    
    https.get(url, (response) => {
        response.pipe(file);
        file.on('finish', () => {
            file.close();
            console.log('受保护文件下载完成');
        });
    });
}
```

### 3.2 Python 示例
```python
import requests

# 下载公开文件
def download_public_file(file_path, output_path):
    url = f"https://my-r2-proxy.your-subdomain.workers.dev/{file_path}"
    response = requests.get(url)
    
    if response.status_code == 200:
        with open(output_path, 'wb') as f:
            f.write(response.content)
        print(f"文件已保存到 {output_path}")
    else:
        print(f"下载失败: {response.status_code}")

# 下载受保护文件
def download_protected_file(file_path, secret_key, output_path):
    params = {'secret': secret_key}
    url = f"https://my-r2-proxy.your-subdomain.workers.dev/protected/{file_path}"
    response = requests.get(url, params=params)
    
    if response.status_code == 200:
        with open(output_path, 'wb') as f:
            f.write(response.content)
        print(f"受保护文件已保存到 {output_path}")
    else:
        print(f"下载失败: {response.status_code}")

# 使用示例
download_public_file("public/data.csv", "local_data.csv")
download_protected_file("private/financials.xlsx", "mySecret123", "financials.xlsx")
```

## 四、实际应用场景

### 4.1 会员内容系统
```html
<!DOCTYPE html>
<html>
<head>
    <title>会员内容系统</title>
</head>
<body>
    <h1>会员专属内容</h1>
    
    <div id="member-content">
        <!-- 根据会员等级显示不同内容 -->
        <button onclick="loadMemberContent('basic')">基础会员内容</button>
        <button onclick="loadMemberContent('premium')">高级会员内容</button>
        <button onclick="loadMemberContent('vip')">VIP会员内容</button>
    </div>

    <script>
        // 根据会员等级加载不同内容
        function loadMemberContent(level) {
            // 从用户会话中获取访问密钥
            const userSecret = localStorage.getItem('access_secret');
            
            let filePath;
            switch(level) {
                case 'basic':
                    filePath = 'members/basic/guide.pdf';
                    break;
                case 'premium':
                    filePath = 'members/premium/report.pdf';
                    break;
                case 'vip':
                    filePath = 'members/vip/exclusive.pdf';
                    break;
                default:
                    alert('未知的会员等级');
                    return;
            }
            
            // 通过代理访问受保护的会员内容
            const url = `https://my-r2-proxy.your-subdomain.workers.dev/protected/${filePath}?secret=${encodeURIComponent(userSecret)}`;
            window.open(url, '_blank');
        }
    </script>
</body>
</html>
```

### 4.2 文件管理系统
```javascript
// 文件管理系统的 JavaScript
class FileManager {
    constructor(workerUrl, secretKey) {
        this.workerUrl = workerUrl;
        this.secretKey = secretKey;
    }
    
    // 上传文件到 R2（通过前端直传或后端代理）
    async uploadFile(file, path) {
        // 注意：上传通常需要直接到 R2 或通过后端 API
        // 此处为概念示例
        console.log('上传文件功能需要额外的上传端点');
    }
    
    // 下载文件
    downloadFile(filePath, isProtected = false) {
        let url;
        if (isProtected) {
            url = `${this.workerUrl}/protected/${filePath}?secret=${encodeURIComponent(this.secretKey)}`;
        } else {
            url = `${this.workerUrl}/${filePath}`;
        }
        
        const link = document.createElement('a');
        link.href = url;
        link.download = filePath.split('/').pop();
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    // 预览文件（仅适用于支持内联显示的格式）
    previewFile(filePath, containerId, isProtected = false) {
        let url;
        if (isProtected) {
            url = `${this.workerUrl}/protected/${filePath}?secret=${encodeURIComponent(this.secretKey)}`;
        } else {
            url = `${this.workerUrl}/${filePath}`;
        }
        
        const container = document.getElementById(containerId);
        
        // 根据文件类型选择预览方式
        const ext = filePath.toLowerCase().split('.').pop();
        if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(ext)) {
            container.innerHTML = `<img src="${url}" style="max-width: 100%; height: auto;">`;
        } else if (['pdf'].includes(ext)) {
            container.innerHTML = `<iframe src="${url}" width="100%" height="600px"></iframe>`;
        } else {
            container.innerHTML = `<a href="${url}" target="_blank">点击下载或预览文件</a>`;
        }
    }
}

// 使用示例
const fileManager = new FileManager(
    'https://my-r2-proxy.your-subdomain.workers.dev',
    'mySecret123'
);

// 下载受保护的文件
fileManager.downloadFile('documents/contract.pdf', true);

// 预览图片
fileManager.previewFile('images/preview.jpg', 'preview-container');
```

## 五、错误处理和调试

### 5.1 常见错误代码及含义
- `401 Unauthorized`: 密钥错误或缺失
- `404 Not Found`: 文件在 R2 中不存在
- `429 Too Many Requests`: 触发速率限制
- `400 Bad Request`: 文件路径包含非法字符

### 5.2 JavaScript 错误处理
```javascript
// 带错误处理的文件访问
async function loadFileWithRetry(filePath, isProtected = false, secretKey = null, maxRetries = 3) {
    let url;
    if (isProtected && secretKey) {
        url = `https://my-r2-proxy.your-subdomain.workers.dev/protected/${filePath}?secret=${encodeURIComponent(secretKey)}`;
    } else {
        url = `https://my-r2-proxy.your-subdomain.workers.dev/${filePath}`;
    }
    
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(url);
            
            if (response.ok) {
                if (response.headers.get('content-type').startsWith('image/')) {
                    // 如果是图片，使用 blob URL
                    const blob = await response.blob();
                    const imageUrl = URL.createObjectURL(blob);
                    return imageUrl;
                } else {
                    // 其他文件类型直接返回响应
                    return response;
                }
            } else if (response.status === 401) {
                console.error('认证失败：请检查密钥是否正确');
                throw new Error('认证失败');
            } else if (response.status === 404) {
                console.error('文件未找到：', filePath);
                throw new Error('文件未找到');
            } else if (response.status === 429) {
                console.warn(`速率限制，等待后重试 (${i + 1}/${maxRetries})`);
                // 等待一段时间后重试
                await new Promise(resolve => setTimeout(resolve, 2000));
            } else {
                console.error(`HTTP错误 ${response.status}:`, response.statusText);
                throw new Error(`HTTP错误: ${response.status}`);
            }
        } catch (error) {
            console.error('请求失败:', error);
            if (i === maxRetries - 1) {
                throw error; // 最后一次重试失败，抛出错误
            }
            // 等待后重试
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

// 使用示例
loadFileWithRetry('protected/private/file.pdf', true, 'mySecret123')
    .then(result => {
        console.log('文件加载成功');
        // 处理成功的结果
    })
    .catch(error => {
        console.error('文件加载失败:', error);
    });
```

## 六、性能优化建议

### 6.1 缓存策略
- 对于公开的静态资源，浏览器会自动缓存
- 受保护的文件由于包含密钥参数，可能不会被缓存
- 考虑实现自定义缓存策略

### 6.2 CDN 优化
- Cloudflare Workers 本身具有全球 CDN 优势
- 文件将通过最近的 Cloudflare 边缘节点提供服务
- 提供优秀的加载速度

### 6.3 批量操作
```javascript
// 批量下载文件
async function batchDownload(fileList, isProtected = false, secretKey = null) {
    const downloadPromises = fileList.map(filePath => {
        return new Promise((resolve, reject) => {
            let url;
            if (isProtected && secretKey) {
                url = `https://my-r2-proxy.your-subdomain.workers.dev/protected/${filePath}?secret=${encodeURIComponent(secretKey)}`;
            } else {
                url = `https://my-r2-proxy.your-subdomain.workers.dev/${filePath}`;
            }
            
            fetch(url)
                .then(response => {
                    if (response.ok) {
                        return response.blob();
                    }
                    throw new Error(`下载失败: ${filePath}`);
                })
                .then(blob => {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filePath.split('/').pop();
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                    resolve(filePath);
                })
                .catch(reject);
        });
    });
    
    try {
        const results = await Promise.all(downloadPromises);
        console.log(`成功下载 ${results.length} 个文件`);
    } catch (error) {
        console.error('批量下载过程中出现错误:', error);
    }
}

// 使用示例：批量下载多个受保护文件
batchDownload(
    ['docs/manual.pdf', 'docs/guide.pdf', 'docs/reference.pdf'],
    true,
    'mySecret123'
);
```

这些示例展示了 Cloudflare R2 代理服务的各种使用方式，从简单到复杂，可以帮助您快速集成到自己的项目中。